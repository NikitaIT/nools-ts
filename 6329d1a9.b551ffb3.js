(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{116:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return d}));var a=t(0),i=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),b=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=b(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},m=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(t),m=a,d=p["".concat(r,".").concat(m)]||p[m]||u[m]||l;return t?i.a.createElement(d,o(o({ref:n},s),{},{components:t})):i.a.createElement(d,o({ref:n},s))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=m;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var s=2;s<l;s++)r[s]=t[s];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},76:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return b}));var a=t(2),i=t(6),l=(t(0),t(116)),r={id:"rule-structure",title:"Rule structure"},o={unversionedId:"rule-structure",id:"version-0.4.1/rule-structure",isDocsHomePage:!1,title:"Rule structure",description:'Lets look at the "Calculate" rule in the Fibonacci example',source:"@site/versioned_docs\\version-0.4.1\\rule-structure.md",permalink:"/nools-ts/docs/0.4.1/rule-structure",editUrl:"https://github.com/nikitait/nools-ts/edit/master/doc-website/versioned_docs/version-0.4.1/rule-structure.md",version:"0.4.1",sidebar:"version-0.4.1/docs",previous:{title:"Working with facts",permalink:"/nools-ts/docs/0.4.1/facts"},next:{title:"Emitting custom events",permalink:"/nools-ts/docs/0.4.1/emitting-custom-events"}},c=[{value:"Salience",id:"salience",children:[]},{value:"Scope",id:"scope",children:[]},{value:"Constraints",id:"constraints",children:[{value:"Custom Constraint",id:"custom-constraint",children:[]},{value:"Not Constraint",id:"not-constraint",children:[]},{value:"Or Constraint",id:"or-constraint",children:[]},{value:"From Constraint",id:"from-constraint",children:[]},{value:"Exists Constraint",id:"exists-constraint",children:[]}]},{value:"Action",id:"action",children:[]},{value:"Async Actions",id:"async-actions",children:[]},{value:"Globals",id:"globals",children:[]},{value:"Importing",id:"importing",children:[]}],s={rightToc:c};function b(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,'Lets look at the "Calculate" rule in the ',Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"#fib"}),"Fibonacci")," example"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'   //flow.rule(type[String|Function], constraints[Array|Array[[]]], action[Function]);\n   flow.rule("Calculate", [\n         //Type     alias  pattern           store sequence to s1\n        [Fibonacci, "f1",  "f1.value != -1", {sequence:"s1"}],\n        [Fibonacci, "f2", "f2.value != -1 && f2.sequence == s1 + 1", {sequence:"s2"}],\n        [Fibonacci, "f3", "f3.value == -1 && f3.sequence == s2 + 1"],\n        [Result, "r"]\n    ], function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    });\n')),Object(l.b)("p",null,"Or using the nools DSL"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"rule Calculate{\n    when {\n        f1 : Fibonacci f1.value != -1 {sequence:s1};\n        f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n        f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n    }\n    then {\n       modify(f3, function(){\n            this.value = f1.value + f2.value;\n       });\n       retract(f1);\n    }\n}\n")),Object(l.b)("h2",{id:"salience"},"Salience"),Object(l.b)("p",null,"Salience is an option that can be specified on a rule giving it a priority and allowing the developer some control over conflict resolution of activations."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'this.rule("Hello4", {salience: 7}, [Message, "m", "m.name == \'Hello\'"], function (facts) {\n});\n\nthis.rule("Hello3", {salience: 8}, [Message, "m", "m.name == \'Hello\'"], function (facts) {\n});\n\nthis.rule("Hello2", {salience: 9}, [Message, "m", "m.name == \'Hello\'"], function (facts) {\n});\n\nthis.rule("Hello1", {salience: 10}, [Message, "m", "m.name == \'Hello\'"], function (facts) {\n});\n')),Object(l.b)("p",null,"Or using the DSL"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"rule Hello4 {\n    salience: 7;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello3 {\n    salience: 8;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello2 {\n    salience: 9;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\nrule Hello1 {\n    salience: 10;\n    when {\n        m: Message m.name == 'hello';\n    }\n    then {}\n}\n\n")),Object(l.b)("p",null,"In the above flow we define four rules each with a different salience, when a single message is asserted they will fire in order of salience (highest to lowest)."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'var fired = [];\nflow1\n    .getSession(new Message("Hello"))\n    .on("fire", function (name) {\n        fired.push(name);\n    })\n    .match()\n    .then(function(){\n        console.log(fired); //["Hello1", "Hello2", "Hello3", "Hello4"]\n    });\n')),Object(l.b)("h2",{id:"scope"},"Scope"),Object(l.b)("p",null,"Scope allows you to access function from within your rules."),Object(l.b)("p",null,"If you are using vanilla JS you can use the ",Object(l.b)("inlineCode",{parentName:"p"},"scope")," option when defining your rule."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\nthis.rule("hello rule", {scope: {isEqualTo: isEqualTo}},\n   [\n      ["or",\n         [String, "s", "isEqualTo(s, \'hello\')"],\n         [String, "s", "isEqualTo(s, \'world\')"]\n      ],\n      [Count, "called", null]\n   ],\n   function (facts) {\n      facts.called.called++;\n   });\n\n\n')),Object(l.b)("p",null,"If you are using the dsl."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'function matches(str, regex){\n    return regex.test(str);\n}\n\nrule Hello {\n    when {\n        m : Message matches(m.text, /^hello\\s*world)?$/);\n    }\n    then {\n        modify(m, function(){\n            this.text += " goodbye";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message matches(m.text, /.*goodbye$/);\n    }\n    then {\n    }\n}\n')),Object(l.b)("p",null,"Or you can pass in a custom function using the scope option in compile."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'rule Hello {\n    when {\n        m : Message doesMatch(m.text, /^hello\\sworld$/);\n    }\n    then {\n        modify(m, function(){\n            this.text += " goodbye";\n        })\n    }\n}\n\nrule Goodbye {\n    when {\n        m : Message doesMatch(m.text, /.*goodbye$/);\n    }\n    then {\n    }\n}\n')),Object(l.b)("p",null,"Provided the ",Object(l.b)("inlineCode",{parentName:"p"},"doesMatch")," function in the scope option of compile."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'function matches(str, regex) {\n   return regex.test(str);\n};\nvar flow = nools.compile(__dirname + "/rules/provided-scope.nools", {scope: {doesMatch: matches}});\n')),Object(l.b)("h2",{id:"constraints"},"Constraints"),Object(l.b)("p",null,"Constraints define what facts the rule should match. The constraint is a array of either a single constraint (i.e. Bootstrap rule) or an array of constraints(i.e. Calculate)."),Object(l.b)("p",null,"Programmatically"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'[\n   //Type     alias  pattern           store sequence to s1\n  [Fibonacci, "f1", "f1.value != -1", {sequence:"s1"}],\n  [Fibonacci, "f2", "f2.value != -1 && f2.sequence == s1 + 1", {sequence:"s2"}],\n  [Fibonacci, "f3", "f3.value == -1 && f3.sequence == s2 + 1"],\n  [Result, "r"]\n]\n')),Object(l.b)("p",null,"Using nools DSL"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"when {\n    f1 : Fibonacci f1.value != -1 {sequence:s1};\n    f2 : Fibonacci f2.value != -1 && f2.sequence == s1 + 1 {sequence:s2};\n    f3 : Fibonacci f3.value == -1 && f3.sequence == s2 + 1;\n    r  : Result;\n}\n")),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"Type -  is the Object type the rule should match. The available types are"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"String"),' - "string", "String", String'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Number"),' - "number", "Number", Number'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Boolean"),' - "boolean", "Boolean", Boolean'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Date"),' - "date", "Date", Date'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"RegExp"),' - "regexp", "RegExp", RegExp'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Array"),' - "array", "Array", [], Array'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Object"),' - "object", "Object", "hash", Object'),Object(l.b)("li",{parentName:"ul"},"Custom - any custom type that you define"))),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"Alias - the name the object should be represented as.")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"Pattern(optional) - The pattern that should evaluate to a boolean, the alias that was used should be used to reference the object in the pattern. Strings should be in single quotes, regular expressions are allowed. Any previously defined alias/reference can be used within the pattern. Available operators are."),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"&&"),", ",Object(l.b)("inlineCode",{parentName:"li"},"AND"),", ",Object(l.b)("inlineCode",{parentName:"li"},"and")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"||"),", ",Object(l.b)("inlineCode",{parentName:"li"},"OR"),", ",Object(l.b)("inlineCode",{parentName:"li"},"or")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},">"),", ",Object(l.b)("inlineCode",{parentName:"li"},"<"),", ",Object(l.b)("inlineCode",{parentName:"li"},">="),", ",Object(l.b)("inlineCode",{parentName:"li"},"<="),", ",Object(l.b)("inlineCode",{parentName:"li"},"gt"),", ",Object(l.b)("inlineCode",{parentName:"li"},"lt"),", ",Object(l.b)("inlineCode",{parentName:"li"},"gte"),", ",Object(l.b)("inlineCode",{parentName:"li"},"lte")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"=="),", ",Object(l.b)("inlineCode",{parentName:"li"},"==="),", ",Object(l.b)("inlineCode",{parentName:"li"},"!="),", ",Object(l.b)("inlineCode",{parentName:"li"},"!=="),", ",Object(l.b)("inlineCode",{parentName:"li"},"=~"),", ",Object(l.b)("inlineCode",{parentName:"li"},"!=~"),", ",Object(l.b)("inlineCode",{parentName:"li"},"eq"),", ",Object(l.b)("inlineCode",{parentName:"li"},"seq"),", ",Object(l.b)("inlineCode",{parentName:"li"},"neq"),", ",Object(l.b)("inlineCode",{parentName:"li"},"sneq"),", ",Object(l.b)("inlineCode",{parentName:"li"},"like"),", ",Object(l.b)("inlineCode",{parentName:"li"},"notLike")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"+"),", ",Object(l.b)("inlineCode",{parentName:"li"},"-"),", ",Object(l.b)("inlineCode",{parentName:"li"},"*"),", ",Object(l.b)("inlineCode",{parentName:"li"},"/"),", ",Object(l.b)("inlineCode",{parentName:"li"},"%")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"-")," (unary minus)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},".")," (member operator)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"in")," (check inclusion in an array)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"notIn")," (check that something is not in an array)"),Object(l.b)("li",{parentName:"ul"},"Defined helper functions",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"now")," - the current date"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Date(year?, month?, day?, hour?, minute?, second?, ms?)")," - creates a new ",Object(l.b)("inlineCode",{parentName:"li"},"Date")," object"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"lengthOf(arr, length)")," - checks the length of an array"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isTrue(something)")," - check if something === true"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isFalse(something)")," - check if something === false"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isRegExp(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"RegExp")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isArray(something)")," - check if something is an ",Object(l.b)("inlineCode",{parentName:"li"},"Array")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isNumber(something)")," - check if something is an ",Object(l.b)("inlineCode",{parentName:"li"},"Number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isHash(something)")," - check if something is strictly an ",Object(l.b)("inlineCode",{parentName:"li"},"Object")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isObject(something)")," - check if something is any type of ",Object(l.b)("inlineCode",{parentName:"li"},"Object")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isDate(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"Date")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isBoolean(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"Boolean")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isString(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"String")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isUndefined(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"undefined")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isDefined(something)")," - check if something is ",Object(l.b)("inlineCode",{parentName:"li"},"Defined")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isUndefinedOrNull(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"undefined")," or ",Object(l.b)("inlineCode",{parentName:"li"},"null")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isPromiseLike(something)"),' - check if something is a "promise" like (containing ',Object(l.b)("inlineCode",{parentName:"li"},"then"),", ",Object(l.b)("inlineCode",{parentName:"li"},"addCallback"),", ",Object(l.b)("inlineCode",{parentName:"li"},"addErrback"),")"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isFunction(something)")," - check if something is a ",Object(l.b)("inlineCode",{parentName:"li"},"Function")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isNull(something)")," - check if something is ",Object(l.b)("inlineCode",{parentName:"li"},"null")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"isNotNull(something)")," - check if something is not null"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"dateCmp(dt1, dt2)")," - compares two dates return 1, -1, or 0"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"(years|months|days|hours|minutes|seconds)(Ago|FromNow)(interval)")," - adds/subtracts the date unit from the current time"))))),Object(l.b)("li",{parentName:"ol"},Object(l.b)("p",{parentName:"li"},"Reference(optional) - An object where the keys are properties on the current object, and values are aliases to use. The alias may be used in succeeding patterns."))),Object(l.b)("h3",{id:"custom-constraint"},"Custom Constraint"),Object(l.b)("p",null,"When declaring your rules progrmmatically you can also use a function as a constraint. The function will be called with an object containing each fact that has matched previous constraints."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'var HelloFact = declare({\n    instance: {\n        value: true,\n        constructor: function (value) {\n            this.value = value;\n        }\n    }\n});\n\nvar flow = nools.flow("custom contraint", function (flow) {\n    flow.rule("hello rule", [HelloFact, "h", function (facts) {\n        return facts.h.value === true;\n    }], function (facts) {\n        console.log(facts.h.value); //always true\n    });\n});\n\nvar session = flow.getSession();\nsession.assert(new HelloFact(false));\nsession.assert(new HelloFact(true));\nsession.match().then(function(){\n    console.log("DONE");\n});\n')),Object(l.b)("h3",{id:"not-constraint"},"Not Constraint"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"not")," constraint allows you to check that particular ",Object(l.b)("inlineCode",{parentName:"p"},"fact")," does ",Object(l.b)("strong",{parentName:"p"},"not")," exist."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n[\n    [Number, "n1"],\n    ["not", Number, "n2", "n1 > n2"]\n]\n\n')),Object(l.b)("p",null,"Or using the DSL."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"\nwhen {\n    n1: Number;\n    not(n2: Number n1 > n2);\n}\n\n")),Object(l.b)("p",null,"The previous example will check that for all numbers in the ",Object(l.b)("inlineCode",{parentName:"p"},"workingMemory")," there is ",Object(l.b)("strong",{parentName:"p"},"not")," one that is greater than ",Object(l.b)("inlineCode",{parentName:"p"},"n1"),"."),Object(l.b)("h3",{id:"or-constraint"},"Or Constraint"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"or")," constraint can be used to check for the existence of multiple facts."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n[\n    ["or",\n        [String, "s", "s == \'hello\'"],\n        [String, "s", "s == \'world\'"],\n        [String, "s", "s == \'hello world\'"]\n    ]\n]\n\n')),Object(l.b)("p",null,"Using the DSL."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"when {\n    or(\n        s : String s == 'hello',\n        s : String s == 'world',\n        s : String s == 'hello world'\n    );\n}\n")),Object(l.b)("p",null,"The previous example will evaluate to ",Object(l.b)("inlineCode",{parentName:"p"},"true")," if you have a string in ",Object(l.b)("inlineCode",{parentName:"p"},"workingMemory")," that equals ",Object(l.b)("inlineCode",{parentName:"p"},"hello"),", ",Object(l.b)("inlineCode",{parentName:"p"},"world, or 'hello world"),"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Or with Not")),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"or")," constraint can be combined with a ",Object(l.b)("inlineCode",{parentName:"p"},"not")," constraint to allow for the checking of multiple not conditions without the implcit and."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'var flow = nools.flow("or condition with not conditions", function (flow) {\n        flow.rule("hello rule", [\n                ["or",\n                    ["not", Number, "n1", "n1 == 1"],\n                    ["not", String, "s1", "s1 == \'hello\'"],\n                    ["not", Date, "d1", "d1.getDate() == now().getDate()"]\n                ],\n                [Count, "called", null]\n            ], function (facts) {\n                facts.called.called++;\n            });\n        });\n});\n')),Object(l.b)("p",null,"or using the dsl."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"rule MultiNotOrRule {\n    when {\n        or (\n            not(n1: Number n1 == 1),\n            not(s1: String s1 == 'hello'),\n            not(d1: Date d1.getDate() == now().getDate())\n        );\n        c: Count;\n    }\n    then{\n        c.called++;\n    }\n}\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note")," Using the ",Object(l.b)("inlineCode",{parentName:"p"},"or")," with a ",Object(l.b)("inlineCode",{parentName:"p"},"not")," will cause the activation to fire for each ",Object(l.b)("inlineCode",{parentName:"p"},"not")," condition that passes. In the above examples if none of the three facts existed then the rule would fire three times."),Object(l.b)("h3",{id:"from-constraint"},"From Constraint"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"from")," modifier allows for the checking of facts that are not necessarily in the ",Object(l.b)("inlineCode",{parentName:"p"},"workingMemory"),"."),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"from")," modifier can be used to access properties on a ",Object(l.b)("inlineCode",{parentName:"p"},"fact")," in ",Object(l.b)("inlineCode",{parentName:"p"},"workingMemory")," or you can use javascript expressions."),Object(l.b)("p",null,"To access properties on a fact you can use the fact name and the property you wish to use as the source for the ",Object(l.b)("inlineCode",{parentName:"p"},"from")," source."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'[\n    [Person, "p"],\n    [Address, "a", "a.zipcode == 88847", "from p.address"],\n    [String, "first", "first == \'bob\'", "from p.firstName"],\n    [String, "last", "last == \'yukon\'", "from p.lastName"]\n]\n')),Object(l.b)("p",null,"Or using the DSL."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"when {\n    p: Person:\n    a: Address a.zipcode == 88847 from p.address;\n    first: String first == 'bob' from p.firstName;\n    last: String last == 'yukon' from p.lastName;\n}\n")),Object(l.b)("p",null,"The above example will used the address, firstName and lastName from the ",Object(l.b)("inlineCode",{parentName:"p"},"person")," fact."),Object(l.b)("p",null,"You can also use the ",Object(l.b)("inlineCode",{parentName:"p"},"from")," modifier to check facts that create a graph."),Object(l.b)("p",null,"For example assume the person object from above has friends that are also of type ",Object(l.b)("inlineCode",{parentName:"p"},"Person"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'[\n    [Person, "p"],\n    [Person, "friend", "friend.firstName != p.firstName", "from p.friends"],\n    [String, "first", "first =~ /^a/", "from friend.firstName"]\n]\n')),Object(l.b)("p",null,"Or using the DSL."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"when {\n    p: Person;\n    friend: Person friend.firstName != p.firstName from p.friends;\n    first: String first =~ /^a/ from friend.firstName;\n}\n")),Object(l.b)("p",null,"The above example will pull the ",Object(l.b)("inlineCode",{parentName:"p"},"friend")," fact from the friends array property on fact ",Object(l.b)("inlineCode",{parentName:"p"},"p"),", and first from the ",Object(l.b)("inlineCode",{parentName:"p"},"friend"),"'s ",Object(l.b)("inlineCode",{parentName:"p"},"firstName"),"."),Object(l.b)("p",null,"You could achieve the same thing using the following code if you assert all friends into working memory."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"when {\n    p: Person;\n    friend: Person friend in p.friends && friend.firstName != p.firstName && p.firstName =~ /^a/;\n}\n")),Object(l.b)("p",null,"To specify the from source as an expression you can do the following."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'[\n    [Number, "n1", "from [1,2,3,4,5]"]\n]\n')),Object(l.b)("p",null,"Or using the dsl"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"{\n    n1: Number from [1,2,3,4,5];\n}\n")),Object(l.b)("p",null,"Using the above syntax you could use ",Object(l.b)("inlineCode",{parentName:"p"},"from")," to bootstrap data."),Object(l.b)("p",null,"You can also use any function defined in the scope of the ",Object(l.b)("inlineCode",{parentName:"p"},"rule")," or ",Object(l.b)("inlineCode",{parentName:"p"},"flow")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\nflow.rule("my rule", {\n    scope: {\n        myArr: function(){\n            return [1,2,3,4,5];\n        }\n    },\n    [Number, "n1", "from myArr()"],\n    function(facts){\n        this.assert(facts.n1);\n    }\n}\n\n')),Object(l.b)("p",null,"Or using the dsl and the ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"#rule-scope"}),"scope")," option."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'rule "my rule", {\n    when {\n        n1: Number from myArr();\n    }\n    then{\n        assert(n1);\n    }\n}\n')),Object(l.b)("h3",{id:"exists-constraint"},"Exists Constraint"),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"exists")," is the logical inversion of a ",Object(l.b)("inlineCode",{parentName:"p"},"not")," constraint. It checks for the existence of a fact in memory."),Object(l.b)("p",null," ",Object(l.b)("strong",{parentName:"p"},"NOTE")," If there are multiple facts that satisfy the constraint the rule will ",Object(l.b)("strong",{parentName:"p"},"ONLY")," be fired once."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'\n[\n    ["exists", Number, "n1", "n1 > 1"]\n]\n\n')),Object(l.b)("p",null," Or using the DSL."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"\nwhen {\n    exists(n1: Number n1 > 1);\n}\n\n")),Object(l.b)("p",null," Assuming the above constraint. The following facts would cause the rule to fire once since there is a number that is greater than 1."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"session.assert(1);\nsession.assert(2);\nsession.assert(3);\nsession.assert(4);\nsession.assert(5);\n")),Object(l.b)("h2",{id:"action"},"Action"),Object(l.b)("p",null,"The action is a function that should be fired when all patterns in the rule match. The action is called in the scope\nof the engine so you can use ",Object(l.b)("inlineCode",{parentName:"p"},"this")," to ",Object(l.b)("inlineCode",{parentName:"p"},"assert"),", ",Object(l.b)("inlineCode",{parentName:"p"},"modify"),", or ",Object(l.b)("inlineCode",{parentName:"p"},"retract")," facts. An object containing all facts and\nreferences created by the alpha nodes is passed in as the first argument to the action."),Object(l.b)("p",null,"So calculate's action modifies f3 by adding the value of f1 and f2 together and modifies f3 and retracts f1."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"function (facts) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        this.modify(f3);\n        this.retract(f1);\n    }\n")),Object(l.b)("p",null,"The session is also passed in as a second argument so alternatively you could do the following."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"function (facts, session) {\n        var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n        var v = f3.value = f1.value + facts.f2.value;\n        facts.r.result = v;\n        session.modify(f3);\n        session.retract(f1);\n    }\n")),Object(l.b)("p",null,"To define the actions with the nools DSL"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"then {\n    modify(f3, function(){\n        this.value = f1.value + f2.value;\n    });\n    retract(f1);\n}\n")),Object(l.b)("p",null,"For rules defined using the rules language nools will automatically determine what parameters need to be passed in based on what is referenced in the action."),Object(l.b)("h2",{id:"async-actions"},"Async Actions"),Object(l.b)("p",null,"If your action is async you can use the third argument which should be called when the action is completed."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"function (facts, engine, next) {\n        //some async action\n        process.nextTick(function(){\n            var f3 = facts.f3, f1 = facts.f1, f2 = facts.f2;\n            var v = f3.value = f1.value + facts.f2.value;\n            facts.r.result = v;\n            engine.modify(f3);\n            engine.retract(f1);\n            next();\n        });\n    }\n")),Object(l.b)("p",null,"If an error occurs you can pass the error as the first argument to ",Object(l.b)("inlineCode",{parentName:"p"},"next"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),'then{\n   saveToDatabase(user, function(err){\n      next(new Error("Something went BOOM!"));\n   });\n}\n')),Object(l.b)("p",null,"If you are using a ",Object(l.b)("a",Object(a.a)({parentName:"p"},{href:"http://promises-aplus.github.io/promises-spec/"}),Object(l.b)("inlineCode",{parentName:"a"},"Promises/A+"))," compliant library you can just return a promise from your action and ",Object(l.b)("inlineCode",{parentName:"p"},"nools")," will wait for the promise to resolve before continuing."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"then{\n   return saveToDatabase(user); // assume saveToDatabase returns a promise\n}\n")),Object(l.b)("h2",{id:"globals"},"Globals"),Object(l.b)("p",null,"Globals are accessible through the current working scope of rules defined in a ",Object(l.b)("inlineCode",{parentName:"p"},"dsl"),", very similar to using the ",Object(l.b)("inlineCode",{parentName:"p"},"scope")," option when compiling."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note"),"  ",Object(l.b)("inlineCode",{parentName:"p"},"globals")," are not part of the working memory and therefore are not accessible in the LHS (when) or your rule."),Object(l.b)("p",null,"Globals are used like the following:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'global PI = Math.PI;\nglobal SOME_STRING = \'some string\';\nglobal TRUE = true;\nglobal NUM = 1.23;\nglobal DATE = new Date();\n\nrule "A Rule" {\n    when {\n        $obj: Object;\n    }\n    then{\n        console.log(PI); //Math.PI;\n        console.log(SOME_STRING); //"some string"\n        console.log(TRUE); //true\n        console.log(NUM); //1.23\n        console.log(DATE); //Thu May 23 2013 15:49:22 GMT-0500 (CDT)\n    }\n}\n')),Object(l.b)("p",null,"If you are using ",Object(l.b)("inlineCode",{parentName:"p"},"nools")," in ",Object(l.b)("inlineCode",{parentName:"p"},"node")," you can also use a require statement."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"NOTE")," require does not currently work for relative paths."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'global util = require("util");\n\nrule "A Rule" {\n    when {\n        $obj: Object;\n    }\n    then{\n        util.log("HELLO WORLD");\n    }\n}\n')),Object(l.b)("h2",{id:"importing"},"Importing"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"import")," statement allows you to import other ",Object(l.b)("inlineCode",{parentName:"p"},"nools")," files into the current one. This can be used to split up logical flows into small reusable groups of rules."),Object(l.b)("p",null,"Define our common model to be used across our flows."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"//define.nools\ndefine Count{\n    constructor: function(){\n        this.called = 0;\n    }\n}\n")),Object(l.b)("p",null,"Create a rules file which imports the ",Object(l.b)("inlineCode",{parentName:"p"},"define.nools")," to define our ",Object(l.b)("inlineCode",{parentName:"p"},"Count")," model."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"//orRule.nools\n\n//import define.nools\nimport(\"./define.nools\");\nrule orRule {\n    when {\n        or(\n            s : String s == 'hello',\n            s : String s == 'world'\n        );\n        count : Count;\n    }\n    then {\n        count.called++;\n        count.s = s;\n    }\n}\n")),Object(l.b)("p",null,"Same as ",Object(l.b)("inlineCode",{parentName:"p"},"orRule.nools")," import our ",Object(l.b)("inlineCode",{parentName:"p"},"define.nools")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),"//notRule.nools\nimport(\"./defines.nools\");\nrule notRule {\n    when {\n        not(s : String s == 'hello');\n        count : Count\n    }\n    then {\n        count.called++;\n    }\n}\n")),Object(l.b)("p",null,"Now we can use ",Object(l.b)("inlineCode",{parentName:"p"},"orRule.nools")," and ",Object(l.b)("inlineCode",{parentName:"p"},"notRule.nools")," to compose a new flow that contains ",Object(l.b)("inlineCode",{parentName:"p"},"define.nools"),", ",Object(l.b)("inlineCode",{parentName:"p"},"orRule.nools")," and ",Object(l.b)("inlineCode",{parentName:"p"},"notRule.nools"),"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Note")," ",Object(l.b)("inlineCode",{parentName:"p"},"nools")," will handle duplicate imports, in this case ",Object(l.b)("inlineCode",{parentName:"p"},"define.nools")," will only be imported once."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'//import\nimport("./orRules.nools");\nimport("./notRules.nools");\n')))}b.isMDXComponent=!0}}]);